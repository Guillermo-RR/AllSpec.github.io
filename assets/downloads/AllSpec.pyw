# -*- coding: utf-8 -*-
"""AllSpec_210

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16AAP6fsNc5k_X2BqpJucBpt2CftrQVJ_
"""

import tkinter as tk
from tkinter import messagebox, filedialog, simpledialog, ttk, colorchooser
import os
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
from scipy.signal import savgol_filter, find_peaks
from PIL import Image, ImageTk
from tkinter import PhotoImage
import base64
import io
import webbrowser
import datetime

logo_base64 = """
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
"""

logo_depto_base64 = """
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
"""

plt.rcParams['font.family'] = 'Times New Roman'
plt.rcParams['axes.linewidth'] = 1.5
plt.rcParams['axes.edgecolor'] = 'black'
plt.rcParams['axes.labelcolor'] = 'black'
plt.rcParams['xtick.color'] = 'black'
plt.rcParams['ytick.color'] = 'black'

# --- UV-Vis ---
class ProcesadorEspectros:
    def __init__(self, master):
        self.master = master
        self.master.title("ðŸ§ª UVVis")
        self.master.geometry("900x780")
        self.master.configure(bg="#e6f0fa")
        self.master.state('zoomed')

        self.etiqueta_x = tk.StringVar(value="Longitud de onda (nm)")
        self.etiqueta_y = tk.StringVar(value="Absorbancia")
        self.xmin = tk.StringVar()
        self.xmax = tk.StringVar()
        self.ymin = tk.StringVar()
        self.ymax = tk.StringVar()

        # Diccionarios para datos y estado de visibilidad
        self.datos_originales = {}
        self.datos_suavizados = {}
        self.mostrar = {}
        self.linea_base = None
        self.limites_originales = None

        self.setup_ui()

    def setup_ui(self):
        estilo_boton1 = {
            "bg": "#398ad7",
            "fg": "white",
            "font": ("Verdana", 10, "bold"),
            "bd": 0,
            "activebackground": "#1f5aa8",
            "activeforeground": "white"
        }

        fuente_label = ("Segoe UI", 9, "bold")
        color_fondo = "#d0e7ff"

        # Variable para ocultar leyenda
        self.var_ocultar_leyenda = tk.BooleanVar(value=False)

        # Frame principal de controles (primera fila de botones)
        frame_controles = tk.Frame(self.master, bg=color_fondo)
        frame_controles.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

# Frame para botones principales (fila 0)
        frame_botones_principales = tk.Frame(frame_controles, bg=color_fondo)
        frame_botones_principales.grid(row=0, column=0, columnspan=10, sticky="w")

        frame_grafica = tk.Frame(self.master, bg="#b0d4fa")
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True , padx=10, pady=5)

# Botones fila 0
        tk.Button(frame_botones_principales, text="ðŸ“‚ Cargar archivos", command=self.cargar_archivos, **estilo_boton1).grid(row=0, column=0, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ‘ï¸ Mostrar/Ocultar selecciÃ³n", command=self.toggle_mostrar_seleccion, **estilo_boton1).grid(row=0, column=1, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ—‘ï¸ Eliminar archivo(s)", command=self.eliminar_archivos, **estilo_boton1).grid(row=0, column=2, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ“Š Actualizar grÃ¡fica", command=self.actualizar_grafica, **estilo_boton1).grid(row=0, column=3, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ’¾ Exportar CSV", command=self.procesar_exportar, **estilo_boton1).grid(row=0, column=4, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ–¼ï¸ Exportar JPG", command=self.exportar_jpg, **estilo_boton1).grid(row=0, column=5, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ”„ Restablecer zoom", command=self.restablecer_zoom, **estilo_boton1).grid(row=0, column=6, padx=5, pady=2)

# Frame para botones secundarios (lÃ­nea base, regresar, etc)
        frame_botones_secundarios = tk.Frame(frame_controles, bg=color_fondo)
        frame_botones_secundarios.grid(row=1, column=0, columnspan=10, sticky="w")

        tk.Button(frame_botones_secundarios, text="ðŸ“ˆ Cargar lÃ­nea base", command=self.cargar_linea_base, **estilo_boton1).grid(row=0, column=0, padx=5, pady=2)
        tk.Button(frame_botones_secundarios, text="â†©ï¸ Regresar al menÃº", command=self.regresar_al_menu, bg="#b21e5a", fg="white", font=fuente_label).grid(row=0, column=6, padx=5, pady=2)

# Ahora etiquetas y entradas debajo en filas siguientes
        tk.Label(frame_controles, text="Etiqueta eje X:", bg=color_fondo, font=fuente_label).grid(row=2, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_x, width=20).grid(row=2, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Etiqueta eje Y:", bg=color_fondo, font=fuente_label).grid(row=2, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_y, width=20).grid(row=2, column=3, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="X min:", bg=color_fondo, font=fuente_label).grid(row=3, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.xmin, width=10).grid(row=3, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="X max:", bg=color_fondo, font=fuente_label).grid(row=3, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.xmax, width=10).grid(row=3, column=3, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Y min:", bg=color_fondo, font=fuente_label).grid(row=4, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.ymin, width=10).grid(row=4, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Y max:", bg=color_fondo, font=fuente_label).grid(row=4, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.ymax, width=10).grid(row=4, column=3, sticky='w', padx=5, pady=2)


        tk.Checkbutton(frame_controles, text="Ocultar leyenda", variable=self.var_ocultar_leyenda, bg=color_fondo,command=self.actualizar_grafica).grid(row=4, column=0, columnspan=2, sticky='w')

        # Frame lista de archivos (lado izquierdo)
        frame_lista = tk.Frame(self.master, bg="#fff0e1")
        frame_lista.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        tk.Label(frame_lista, text="Archivos cargados:", bg="#fff0e1", font=("Segoe UI", 10, "bold")).pack(anchor='w')
        self.listbox = tk.Listbox(frame_lista, selectmode=tk.EXTENDED, width=35, height=32)
        self.listbox.pack(fill=tk.BOTH, expand=True, pady=5)

    # Frame grÃ¡fico (lado derecho)
        frame_grafica = tk.Frame(self.master, bg="#b0d4fa")
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True , padx=10, pady=5)

    # Figura y canvas matplotlib (solo una vez)
        self.fig = Figure(figsize=(7.5, 5))  # Ajusta tamaÃ±o si quieres
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_grafica)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.toolbar = NavigationToolbar2Tk(self.canvas, frame_grafica)
        self.toolbar.update()
        self.toolbar.pack(side=tk.BOTTOM, fill=tk.X)

    def leer_datos(self, archivo):
        longitudes = []
        absorbancias = []
        with open(archivo, 'r', encoding='utf-8', errors='ignore') as f:
            for linea in f:
                linea = linea.strip()
                if not linea or not any(c.isdigit() for c in linea):
                    continue
                partes = linea.replace(',', ' ').split()
                if len(partes) >= 2:
                    try:
                        x = float(partes[0])
                        y = float(partes[1])
                        longitudes.append(x)
                        absorbancias.append(y)
                    except ValueError:
                        continue
        if len(longitudes) < 5:
            raise ValueError("Datos insuficientes")
        return np.array(longitudes), np.array(absorbancias)

    def cargar_archivos(self):
        rutas = filedialog.askopenfilenames(title="Selecciona archivos UV-Vis",
                                            filetypes=[("Archivos UV-Vis", "*.csv *.ascii *.dat *.sp *.rls")])
        if not rutas:
            return

        nuevos_cargados = 0
        for ruta in rutas:
            nombre = os.path.splitext(os.path.basename(ruta))[0]
            if nombre in self.datos_originales:
                messagebox.showwarning("Archivo duplicado", f"El archivo '{nombre}' ya fue cargado.")
                continue
            try:
                x, y = self.leer_datos(ruta)
                if len(y) >= 11:
                    y_suave = savgol_filter(y, 11, 3)
                else:
                    y_suave = y
                self.datos_originales[nombre] = (x, y)
                self.datos_suavizados[nombre] = (x, y_suave)
                self.mostrar[nombre] = True
                self.listbox.insert(tk.END, nombre)
                nuevos_cargados += 1
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo cargar '{nombre}': {e}")

        if nuevos_cargados > 0:
            self.actualizar_grafica()

    def toggle_mostrar_seleccion(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona uno o mÃ¡s archivos en la lista para mostrar u ocultar.")
            return
        for idx in seleccion:
            nombre = self.listbox.get(idx)
            self.mostrar[nombre] = not self.mostrar.get(nombre, True)
        self.actualizar_grafica()

    def eliminar_archivos(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona uno o mÃ¡s archivos para eliminar.")
            return
        archivos_eliminar = [self.listbox.get(i) for i in seleccion]
        if not messagebox.askyesno("Confirmar eliminaciÃ³n", f"Â¿Eliminar {len(archivos_eliminar)} archivo(s) seleccionado(s)?"):
            return
        for nombre in archivos_eliminar:
            self.datos_originales.pop(nombre, None)
            self.datos_suavizados.pop(nombre, None)
            self.mostrar.pop(nombre, None)
        for i in reversed(seleccion):
            self.listbox.delete(i)
        self.actualizar_grafica()

    def actualizar_grafica(self):
    # Guardar lÃ­mites actuales antes de limpiar
        if self.ax.has_data():
            current_xlim = self.ax.get_xlim()
            current_ylim = self.ax.get_ylim()
        else:
            current_xlim, current_ylim = None, None

        self.ax.clear()
        any_data = False
        for nombre in self.datos_originales:
            if self.mostrar.get(nombre, True):
                x, y = self.datos_suavizados[nombre]
                if self.linea_base is not None:
                    y_corr = np.array([yi - self.linea_base.get(xi, 0) for xi, yi in zip(x, y)])
                else:
                    y_corr = y
                self.ax.plot(x, y_corr, label=nombre)
                any_data = True

    # Configuraciones estÃ©ticas
        self.ax.set_xlabel(self.etiqueta_x.get(), fontsize=14)
        self.ax.set_ylabel(self.etiqueta_y.get(), fontsize=14)
        self.ax.grid(False)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))
        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)
        self.ax.minorticks_on()
        self.ax.tick_params(axis='both', which='minor', length=3)

        if any_data and not self.var_ocultar_leyenda.get():
            self.ax.legend()

    # Aplicar lÃ­mites sÃ³lo si el usuario los definiÃ³
        try:
            xmin = float(self.xmin.get()) if self.xmin.get() else None
            xmax = float(self.xmax.get()) if self.xmax.get() else None
            ymin = float(self.ymin.get()) if self.ymin.get() else None
            ymax = float(self.ymax.get()) if self.ymax.get() else None

            if xmin is not None and xmax is not None:
                self.ax.set_xlim(xmin, xmax)
            elif current_xlim is not None:
                self.ax.set_xlim(current_xlim)  # preserva zoom actual

            if ymin is not None and ymax is not None:
                self.ax.set_ylim(ymin, ymax)
            elif current_ylim is not None:
                self.ax.set_ylim(current_ylim)  # preserva zoom actual
        except ValueError:
            messagebox.showwarning("LÃ­mites invÃ¡lidos", "Los valores de lÃ­mites deben ser numÃ©ricos.")

    # Actualiza lÃ­mites originales sÃ³lo si no hay zoom activo o usuario no ha cambiado los lÃ­mites
        if not any([self.xmin.get(), self.xmax.get(), self.ymin.get(), self.ymax.get()]):
            if any_data:
                self.limites_originales = (self.ax.get_xlim(), self.ax.get_ylim())

        self.canvas.draw_idle()

    def procesar_exportar(self):
        if not self.datos_originales:
            messagebox.showwarning("Advertencia", "No hay datos para exportar.")
            return

        nombre_base = simpledialog.askstring("Nombre base", "Ingrese nombre base para exportar:")
        if not nombre_base:
            return

        archivo = filedialog.asksaveasfilename(defaultextension=".csv",
                                           filetypes=[("CSV files", "*.csv")])
        if not archivo:
            return

        # Obtener longitudes desde datos originales y ordenar de mayor a menor
        longitudes = self.datos_originales[list(self.datos_originales.keys())[0]][0]
        indices_ordenados = sorted(range(len(longitudes)), key=lambda i: longitudes[i])

        with open(archivo, 'w', encoding='utf-8') as f:
            encabezado = ["Longitud_de_onda"] + [n for n in self.datos_originales if self.mostrar.get(n, True)]
            f.write(",".join(encabezado) + "\n")

            for i in indices_ordenados:
                fila = [f"{longitudes[i]:.3f}"]
                for nombre in self.datos_originales:
                    if self.mostrar.get(nombre, True):
                        y = self.datos_originales[nombre][1][i]
                        if self.linea_base is not None:
                            y -= self.linea_base.get(longitudes[i], 0)
                        fila.append(f"{y:.6f}")
                f.write(",".join(fila) + "\n")

        messagebox.showinfo("ExportaciÃ³n", f"Archivo exportado como: {archivo}")

    def exportar_jpg(self):
        archivo = filedialog.asksaveasfilename(defaultextension=".jpg",
                                               filetypes=[("JPG files", "*.jpg"), ("PNG files", "*.png")])
        if not archivo:
            return
        self.fig.savefig(archivo, dpi=300)
        messagebox.showinfo("ExportaciÃ³n", f"GrÃ¡fica guardada como {archivo}")

    def restablecer_zoom(self):
        if self.limites_originales:
            self.ax.set_xlim(self.limites_originales[0])
            self.ax.set_ylim(self.limites_originales[1])
            self.canvas.draw()

    def regresar_al_menu(self):
        self.master.destroy()
        root_menu = tk.Tk()
        app = AppPrincipal(root_menu)
        root_menu.mainloop()


    def cargar_linea_base(self):
        ruta = filedialog.askopenfilename(title="Seleccione lÃ­nea base",
                                          filetypes=[("Archivos UV-Vis", "*.csv *.ascii *.dat *.sp *.rls")])
        if not ruta:
            return
        try:
            x, y = self.leer_datos(ruta)
            self.linea_base = dict(zip(x, y))
            messagebox.showinfo("LÃ­nea base", "LÃ­nea base cargada correctamente")
            self.actualizar_grafica()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar la lÃ­nea base: {e}")

# --- IR ---

class ProcesadorIR:
    def __init__(self, master):
        self.master = master
        self.master.title("Infrarrojo")
        self.master.geometry("1000x800")
        self.master.configure(bg="#e8f5e9")
        self.master.state('zoomed')

        self.datos_originales = {}
        self.datos_suavizados = {}
        self.mostrar = {}
        self.limites_originales = None
        self.colores = {}
        self.var_ocultar_leyenda = tk.BooleanVar(value=False)

        self.etiqueta_x = tk.StringVar(value="NÃºmero de onda (cmâ»Â¹)")
        self.etiqueta_y = tk.StringVar(value="% Transmitancia")
        self.xmin = tk.StringVar()
        self.xmax = tk.StringVar()
        self.ymin = tk.StringVar()
        self.ymax = tk.StringVar()

        color_fondo = "#ffe6f0"
        fuente_label = ("Segoe UI", 9, "bold")

        frame_controles = tk.Frame(master, bg=color_fondo)
        frame_controles.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        frame_lista = tk.Frame(master, bg="#ffe6f0")
        frame_lista.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        frame_grafica = tk.Frame(master, bg="#800040")
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        estilo_boton = {
            "bg": "#cc6699",
            "fg": "white",
            "font": ("Verdana", 10, "bold"),
            "bd": 0,
            "activebackground": "#388e3c",
            "activeforeground": "white"
        }

        botones = [
            ("ðŸ“‚ Cargar archivos IR", self.cargar_archivos),
            ("ðŸ‘ï¸ Mostrar/Ocultar", self.toggle_mostrar_seleccion),
            ("ðŸ—‘ï¸ Eliminar", self.eliminar_archivos),
            ("ðŸ“Š Actualizar grÃ¡fica", self.actualizar_grafica),
            ("ðŸ’¾ Exportar CSV", self.exportar_csv),
            ("ðŸ–¼ï¸ Exportar JPG", self.exportar_jpg),
            ("ðŸ”„ Restablecer zoom", self.restablecer_zoom),
            ("ðŸ“ˆ Detectar picos", self.detectar_picos)
        ]
        for idx, (txt, cmd) in enumerate(botones):
            tk.Button(frame_controles, text=txt, command=cmd, **estilo_boton).grid(row=0, column=idx, padx=5)

        tk.Checkbutton(frame_controles, text="Ocultar leyenda", variable=self.var_ocultar_leyenda,
                       bg=color_fondo, font=fuente_label, command=self.actualizar_grafica).grid(row=4, column=0, sticky='w', padx=5)

        tk.Button(frame_controles, text="ðŸŽ¨ Cambiar color", command=self.cambiar_color, **estilo_boton).grid(row=1, column=1, padx=5, pady=5)

        tk.Button(frame_controles, text="ðŸ”™ Regresar al menÃº", command=self.regresar_al_menu,
                  bg="#b21e5a", fg="white", font=fuente_label, bd=0).grid(row=1, column=6, padx=5, pady=5)

        labels = [
            ("Etiqueta eje X:", self.etiqueta_x),
            ("Etiqueta eje Y:", self.etiqueta_y),
            ("X min:", self.xmin),
            ("X max:", self.xmax),
            ("Y min:", self.ymin),
            ("Y max:", self.ymax)
        ]
        for i, (texto, var) in enumerate(labels):
            row, col = 2 + i // 2, (i % 2) * 2
            tk.Label(frame_controles, text=texto, bg=color_fondo, font=fuente_label).grid(row=row, column=col, sticky='e', padx=5, pady=2)
            tk.Entry(frame_controles, textvariable=var, width=20).grid(row=row, column=col+1, sticky='w', padx=5, pady=2)

        tk.Label(frame_lista, text="Archivos cargados:", bg="#fff0e1", font=("Segoe UI", 10, "bold")).pack(anchor='w')
        self.listbox = tk.Listbox(frame_lista, selectmode=tk.EXTENDED, width=35, height=32)
        self.listbox.pack(fill=tk.BOTH, expand=True, pady=5)

        self.fig = Figure(figsize=(7, 5))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_grafica)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.toolbar = NavigationToolbar2Tk(self.canvas, frame_grafica)
        self.toolbar.update()
        self.toolbar.pack(side=tk.BOTTOM, fill=tk.X)

    def cambiar_color(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona un espectro para cambiar su color.")
            return
        nombre = self.listbox.get(seleccion[0])
        color = colorchooser.askcolor(title="Selecciona un color")[1]
        if color:
            self.colores[nombre] = color
            self.actualizar_grafica()

    def leer_ir_datos(self, archivo):
        con_datos = False
        x, y = [], []
        with open(archivo, 'r', encoding='utf-8', errors='ignore') as f:
            for linea in f:
                linea = linea.strip()
                if "#DATA" in linea:
                    con_datos = True
                    continue
                if con_datos:
                    if not linea or not any(c.isdigit() for c in linea):
                        continue
                    partes = linea.replace(',', ' ').split()
                    if len(partes) >= 2:
                        try:
                            x.append(float(partes[0]))
                            y.append(float(partes[1]))
                        except ValueError:
                            continue
        if len(x) < 5:
            raise ValueError("Datos insuficientes o mal formateados.")
        return np.array(x), np.array(y)

    def cargar_archivos(self):
        rutas = filedialog.askopenfilenames(title="Selecciona archivos IR", filetypes=[("Archivos IR", "*.asc *.txt")])
        if not rutas:
            return

        for ruta in rutas:
            nombre = os.path.splitext(os.path.basename(ruta))[0]
            if nombre in self.datos_originales:
                messagebox.showwarning("Duplicado", f"El archivo '{nombre}' ya estÃ¡ cargado.")
                continue
            try:
                x, y = self.leer_ir_datos(ruta)
                y_suave = savgol_filter(y, 11, 3) if len(y) >= 11 else y
                self.datos_originales[nombre] = (x, y)
                self.datos_suavizados[nombre] = (x, y_suave)
                self.mostrar[nombre] = True
                self.listbox.insert(tk.END, nombre)
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo cargar '{nombre}': {e}")

        self.actualizar_grafica()

    def actualizar_grafica(self):
        self.ax.clear()
        any_data = False
        for nombre in self.datos_originales:
            if self.mostrar.get(nombre, True):
                x, y = self.datos_suavizados[nombre]
                color = self.colores.get(nombre, None)
                self.ax.plot(x, y, label=nombre, color=color)
                any_data = True
        self.ax.set_xlabel("NÃºmero de onda (cmâ»Â¹)", fontsize=14)
        self.ax.set_ylabel("% Transmitancia", fontsize=14)
        self.ax.invert_xaxis()
        self.ax.grid(False)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))

        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)

        self.ax.minorticks_on()
        self.ax.tick_params(axis='both', which='minor', length=3)

        if any_data and not self.var_ocultar_leyenda.get():
            self.ax.legend()
        if any_data:
            self.limites_originales = (self.ax.get_xlim(), self.ax.get_ylim())
        self.canvas.draw()

    def actualizar_grafica(self):
        self.ax.clear()
        any_data = False
        for nombre in self.datos_originales:
            if self.mostrar.get(nombre, True):
                x, y = self.datos_suavizados[nombre]
                color = self.colores.get(nombre, None)
                self.ax.plot(x, y, label=nombre, color=color)
                any_data = True

        self.ax.set_xlabel(self.etiqueta_x.get(), fontsize=14)
        self.ax.set_ylabel(self.etiqueta_y.get(), fontsize=14)
        self.ax.invert_xaxis()
        self.ax.grid(False)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))
        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)
        self.ax.minorticks_on()
        self.ax.tick_params(axis='both', which='minor', length=3)

        if any_data and not self.var_ocultar_leyenda.get():
            self.ax.legend()

    # Aplicar lÃ­mites si se especifican
        try:
            xmin = float(self.xmin.get()) if self.xmin.get() else None
            xmax = float(self.xmax.get()) if self.xmax.get() else None
            ymin = float(self.ymin.get()) if self.ymin.get() else None
            ymax = float(self.ymax.get()) if self.ymax.get() else None

            if xmin is not None and xmax is not None:
                self.ax.set_xlim(xmin, xmax)
            if ymin is not None and ymax is not None:
                self.ax.set_ylim(ymin, ymax)
        except ValueError:
           messagebox.showwarning("LÃ­mites invÃ¡lidos", "Los lÃ­mites deben ser numÃ©ricos.")

    # Guardar lÃ­mites originales
        if any_data and not any([self.xmin.get(), self.xmax.get(), self.ymin.get(), self.ymax.get()]):
            self.limites_originales = (self.ax.get_xlim(), self.ax.get_ylim())

        self.canvas.draw_idle()

    def detectar_picos(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona un archivo para detectar picos.")
            return

        nombre = self.listbox.get(seleccion[0])
        x, y = self.datos_suavizados[nombre]

        picos, props = find_peaks(-y, prominence=0.5)

        if len(picos) == 0:
            messagebox.showinfo("Resultado", "No se detectaron picos prominentes.")
            return

        self.actualizar_grafica()
        self.ax.plot(x[picos], y[picos], 'ro', label="Picos")
        self.ax.legend()
        self.canvas.draw()

        self.mostrar_tabla_picos(x[picos], y[picos])

    def mostrar_tabla_picos(self, x_picos, y_picos):
        top = tk.Toplevel(self.master)
        top.title("Picos detectados")
        tree = ttk.Treeview(top, columns=("cmâ»Â¹", "%T"), show="headings")
        tree.heading("cmâ»Â¹", text="NÃºmero de onda (cmâ»Â¹)")
        tree.heading("%T", text="% Transmitancia")

        for xi, yi in zip(x_picos, y_picos):
            tree.insert("", tk.END, values=(f"{xi:.2f}", f"{yi:.2f}"))

        tree.pack(fill=tk.BOTH, expand=True)
        btn_exportar = tk.Button(top, text="Exportar picos a CSV", command=lambda: self.exportar_picos_csv(x_picos, y_picos))
        btn_exportar.pack(pady=5)

    def exportar_picos_csv(self, x, y):
        archivo = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")])
        if not archivo:
            return
        with open(archivo, 'w', encoding='utf-8') as f:
            f.write("Numero_de_onda,%T\n")
            for xi, yi in zip(x, y):
                f.write(f"{xi:.2f},{yi:.2f}\n")
        messagebox.showinfo("ExportaciÃ³n", f"Picos exportados a: {archivo}")

    def toggle_mostrar_seleccion(self):
        seleccion = self.listbox.curselection()
        for idx in seleccion:
            nombre = self.listbox.get(idx)
            self.mostrar[nombre] = not self.mostrar.get(nombre, True)
        self.actualizar_grafica()

    def eliminar_archivos(self):
        seleccion = self.listbox.curselection()
        for idx in reversed(seleccion):
            nombre = self.listbox.get(idx)
            del self.datos_originales[nombre]
            del self.datos_suavizados[nombre]
            del self.mostrar[nombre]
            self.listbox.delete(idx)
        self.actualizar_grafica()

    def exportar_csv(self):
        if not self.datos_suavizados:
            return
        archivo = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")])
        if not archivo:
            return

        x_ref = list(self.datos_suavizados.values())[0][0]
        with open(archivo, 'w', encoding='utf-8') as f:
            encabezado = ["Numero_de_onda"] + [n for n in self.datos_suavizados if self.mostrar.get(n, True)]
            f.write(",".join(encabezado) + "\n")
            for i in range(len(x_ref)):
                fila = [f"{x_ref[i]:.2f}"]
                for nombre in self.datos_suavizados:
                    if self.mostrar.get(nombre, True):
                        y = self.datos_suavizados[nombre][1][i]
                        fila.append(f"{y:.6f}")
                f.write(",".join(fila) + "\n")
        messagebox.showinfo("ExportaciÃ³n", f"Archivo exportado como: {archivo}")

    def exportar_jpg(self):
        archivo = filedialog.asksaveasfilename(defaultextension=".jpg", filetypes=[("JPG", "*.jpg"), ("PNG", "*.png")])
        if archivo:
            self.fig.savefig(archivo, dpi=300)
            messagebox.showinfo("ExportaciÃ³n", f"GrÃ¡fica guardada como {archivo}")

    def restablecer_zoom(self):
        if self.limites_originales:
            self.ax.set_xlim(self.limites_originales[0])
            self.ax.set_ylim(self.limites_originales[1])
            self.canvas.draw()

    def regresar_al_menu(self):
        self.master.destroy()
        root_menu = tk.Tk()
        app = AppPrincipal(root_menu)
        root_menu.mainloop()


# --- VOLTAM ---
class CVApp:
    def __init__(self, master):
        self.master = master
        self.master.title("VoltamperometrÃ­a y cronamperometrÃ­a")
        self.master.geometry("900x700")
        self.master.configure(bg="#fff4e6")
        self.master.state('zoomed')
        self.datos_corregidos = {}
        self.usando_correccion_blanco = False
        self.colores_archivo = {}
        self.colores = {}


        self.archivos = []
        self.datos_originales = {}
        self.datos_blanco = None
        self.etiqueta_x = tk.StringVar(value="Potencial (V)")
        self.etiqueta_y = tk.StringVar(value="Corriente (A)")
        self.xmin = tk.StringVar()
        self.xmax = tk.StringVar()
        self.ymin = tk.StringVar()
        self.ymax = tk.StringVar()
        self.ocultar_leyenda = tk.BooleanVar(value=False)

        self.setup_ui()

    def setup_ui(self):

        estilo_boton = {
            "bg": "#f97f51",
            "fg": "white",
            "font": ("Segoe UI", 10, "bold"),
            "bd": 0,
            "activebackground": "#cc9966",
            "activeforeground": "white"
        }

        frame_controles = tk.Frame(self.master, bg="#ffe6cc")
        frame_controles.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        frame_lista = tk.Frame(self.master, bg="#ffe6cc")
        frame_lista.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        frame_grafica = tk.Frame(self.master, bg="#ffe6cc")
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Etiquetas y entradas
        fuente_label = ("Segoe UI", 9, "bold")
        color_fondo = "#fff0e1"

            # Dividir controles en dos filas para botones principales y secundarios
        frame_botones_principales = tk.Frame(frame_controles, bg=color_fondo)
        frame_botones_principales.grid(row=0, column=0, columnspan=10, sticky="w")

        frame_botones_secundarios = tk.Frame(frame_controles, bg=color_fondo)
        frame_botones_secundarios.grid(row=1, column=0, columnspan=10, sticky="w")

    # Botones fila principal (fila 0)
        tk.Button(frame_botones_principales, text="ðŸ“‚ Cargar archivos", command=self.cargar_archivos, **estilo_boton).grid(row=0, column=0, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ—‘ï¸ Eliminar archivo", command=self.eliminar_archivo, **estilo_boton).grid(row=0, column=1, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="âšª Cargar blanco", command=self.cargar_blanco, **estilo_boton).grid(row=0, column=2, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="âš–ï¸ Corregir con blanco", command=self.corregir_con_blanco, **estilo_boton).grid(row=0, column=3, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ“Š Graficar", command=self.graficar, **estilo_boton).grid(row=0, column=4, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ’¾ Exportar CSV", command=self.exportar_csv, **estilo_boton).grid(row=0, column=5, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ–¼ï¸ Exportar JPG", command=self.exportar_jpg, **estilo_boton).grid(row=0, column=6, padx=5, pady=2)
        tk.Button(frame_botones_principales, text="ðŸ”„ Restablecer zoom", command=self.restablecer_zoom, **estilo_boton).grid(row=0, column=7, padx=5, pady=2)

    # Botones fila secundaria (fila 1)
        tk.Button(frame_botones_secundarios, text="ðŸ”™ Regresar al menÃº", command=self.regresar_al_menu, bg="#b21e5a", fg="White", font=fuente_label).grid(row=0, column=2, padx=5, pady=2)
        tk.Button(frame_botones_secundarios, text="â†”ï¸ Alternar original/corregido", command=self.alternar_correccion_blanco, **estilo_boton).grid(row=0, column=1, padx=5, pady=2)
        tk.Button(frame_botones_secundarios, text="ðŸŽ¨ Cambiar color", command=self.cambiar_color, **estilo_boton).grid(row=0, column=0, padx=5, pady=2)

    # Etiquetas y entradas para ejes (debajo de botones)
        tk.Label(frame_controles, text="Etiqueta eje X:", bg=color_fondo, font=fuente_label).grid(row=2, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_x, width=15).grid(row=2, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Etiqueta eje Y:", bg=color_fondo, font=fuente_label).grid(row=2, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_y, width=15).grid(row=2, column=3, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="X min:", bg=color_fondo, font=fuente_label).grid(row=3, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.xmin, width=10).grid(row=3, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="X max:", bg=color_fondo, font=fuente_label).grid(row=3, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.xmax, width=10).grid(row=3, column=3, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Y min:", bg=color_fondo, font=fuente_label).grid(row=4, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.ymin, width=10).grid(row=4, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Y max:", bg=color_fondo, font=fuente_label).grid(row=4, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.ymax, width=10).grid(row=4, column=3, sticky='w', padx=5, pady=2)

    # Checkbox ocultar leyenda (fila 5)
        tk.Checkbutton(frame_controles, text="Ocultar leyenda", variable=self.ocultar_leyenda, bg=color_fondo, font=fuente_label, command=self.graficar).grid(row=5, column=0, columnspan=2, sticky='w', padx=5, pady=2)

    # Listbox para archivos (lado izquierdo)
        tk.Label(frame_lista, text="Archivos cargados:", bg="#fff0e1", font=("Segoe UI", 10, "bold")).pack(anchor='w')
        self.listbox = tk.Listbox(frame_lista, selectmode=tk.EXTENDED, width=40, height=32)
        self.listbox.pack(fill=tk.BOTH, expand=True, pady=5)

    # Ãrea grÃ¡fica (lado derecho)
        self.fig = Figure(figsize=(7.5, 5))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_grafica)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.toolbar = NavigationToolbar2Tk(self.canvas, frame_grafica)
        self.toolbar.update()
        self.toolbar.pack(side=tk.BOTTOM, fill=tk.X)

    def cambiar_color(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona un archivo para cambiar su color.")
            return
        nombre = self.listbox.get(seleccion[0])
        color = colorchooser.askcolor(title=f"Selecciona un color para {nombre}")[1]
        if color:
            self.colores[nombre] = color
            self.graficar()


    def cargar_blanco(self):
        ruta = filedialog.askopenfilename(title="Seleccionar archivo blanco",
                                          filetypes=[("Archivos CV", "*.sp *.txt *.csv *.dat")])
        if not ruta:
            return
        try:
            pot, corr = self.leer_cv_datos(ruta)
            self.datos_blanco = (pot, corr)
            messagebox.showinfo("Blanco cargado", f"Archivo blanco cargado correctamente:\n{os.path.basename(ruta)}")
            if self.archivos:
                self.corregir_con_blanco()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar el archivo blanco:\n{e}")

    def corregir_con_blanco(self):
        if not self.archivos:
            messagebox.showinfo("Info", "No hay archivos para corregir.")
            return
        if self.datos_blanco is None:
            messagebox.showwarning("AtenciÃ³n", "No ha cargado archivo blanco.")
            return

        pot_blanco, corr_blanco = self.datos_blanco

        self.datos_corregidos.clear()

        for nombre in self.archivos:
            pot, corr = self.datos_originales[nombre]
            if not np.array_equal(pot, pot_blanco):
                corr_blanco_interp = np.interp(pot, pot_blanco, corr_blanco)
            else:
                corr_blanco_interp = corr_blanco
            y_corr = corr - corr_blanco_interp
            self.datos_corregidos[nombre] = (pot, y_corr)

        self.usando_correccion_blanco = True
        messagebox.showinfo("CorrecciÃ³n con blanco", "Se realizÃ³ la correcciÃ³n con el archivo blanco.")
        self.graficar(usando_corregidos=True)

    def regresar_al_menu(self):
        self.master.destroy()
        root_menu = tk.Tk()
        app = AppPrincipal(root_menu)
        root_menu.mainloop()

    def corregir_linea_base(self):
        if not self.archivos:
            messagebox.showinfo("Info", "No hay archivos para corregir.")
            return

        self.datos_corregidos.clear()
        for nombre in self.archivos:
            x, y = self.datos_originales[nombre]
            coef = np.polyfit(x, y, 1)
            linea_base = np.polyval(coef, x)
            y_corr = y - linea_base
            self.datos_corregidos[nombre] = (x, y_corr)

        self.graficar(usando_corregidos=True)

    def restablecer_zoom(self):
        self.xmin.set("")
        self.xmax.set("")
        self.ymin.set("")
        self.ymax.set("")
        self.graficar()

    def leer_cv_datos(self, archivo):
        import re
        potenciales, corrientes = [], []
        patron = re.compile(r'^[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?[\s,]+[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?$')

        with open(archivo, 'r', encoding='utf-8', errors='ignore') as f:
            for linea in f:
                linea = linea.strip().replace('\u2212', '-')
                if not linea:
                    continue
                if not patron.match(linea):
                    continue
                if ',' in linea:
                    partes = linea.split(',')
                else:
                    partes = re.split(r'[ \t]+', linea)
                if len(partes) != 2:
                    continue
                try:
                    x = float(partes[0])
                    y = float(partes[1])
                    potenciales.append(x)
                    corrientes.append(y)
                except ValueError:
                    continue
        if not potenciales:
            raise ValueError("No se encontraron datos numÃ©ricos vÃ¡lidos.")
        return np.array(potenciales), np.array(corrientes)

    def cargar_archivos(self):
        rutas = filedialog.askopenfilenames(title="Seleccionar archivos CV",
                                        filetypes=[("Archivos CV", "*.sp *.txt *.csv *.dat")])
        nuevos = False
        for ruta in rutas:
            nombre = os.path.basename(ruta)
            if nombre in self.archivos:
                continue
            try:
                pot, corr = self.leer_cv_datos(ruta)
                self.archivos.append(nombre)
                self.listbox.insert(tk.END, nombre)
                self.datos_originales[nombre] = (pot, corr)
                nuevos = True
            except Exception as e:
                messagebox.showerror("Error", f"Error al leer {nombre}: {e}")

        if nuevos:
            self.graficar()

    def eliminar_archivo(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona uno o mÃ¡s archivos para eliminar.")
            return

        nombres = [self.listbox.get(i) for i in seleccion]
        confirmacion = messagebox.askyesno("Confirmar", f"Â¿Eliminar {len(nombres)} archivo(s) del programa?\n\n" + "\n".join(nombres))
        if not confirmacion:
            return

        for i in reversed(seleccion):  # Eliminar de la lista en orden inverso
            nombre = self.listbox.get(i)
            self.listbox.delete(i)
            if nombre in self.archivos:
                self.archivos.remove(nombre)
            self.datos_originales.pop(nombre, None)
            self.datos_corregidos.pop(nombre, None)
            self.colores.pop(nombre, None)
            self.colores_archivo.pop(nombre, None)
            if self.datos_blanco == nombre:
                self.datos_blanco = None

        self.graficar()


    def graficar(self, usando_corregidos=False):
        if not self.archivos:
            messagebox.showinfo("Info", "No hay archivos para graficar.")
            return

        self.ax.clear()
        for nombre in self.archivos:
            color = self.colores.get(nombre, None)
            if self.usando_correccion_blanco and nombre in self.datos_corregidos:
                pot, corr = self.datos_corregidos[nombre]
                etiqueta = f"{nombre} (corregido)"
            else:
                pot, corr = self.datos_originales[nombre]
                etiqueta = nombre
            self.ax.plot(pot, corr, label=etiqueta, color=color)

        self.ax.set_xlabel(self.etiqueta_x.get(), fontsize=14)
        self.ax.set_ylabel(self.etiqueta_y.get(), fontsize=14)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))
        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)
        self.ax.minorticks_on()
        self.ax.tick_params(axis='both', which='minor', length=3)

        try:
            if self.xmin.get():
                self.ax.set_xlim(left=float(self.xmin.get()))
            if self.xmax.get():
                self.ax.set_xlim(right=float(self.xmax.get()))
            if self.ymin.get():
                self.ax.set_ylim(bottom=float(self.ymin.get()))
            if self.ymax.get():
                self.ax.set_ylim(top=float(self.ymax.get()))
        except ValueError:
            messagebox.showwarning("Error", "Rangos invÃ¡lidos, se usarÃ¡ automÃ¡tico.")

        self.ax.grid(False)
        if not self.ocultar_leyenda.get():
            self.ax.legend(fontsize=10)

        self.canvas.draw()

    def alternar_correccion_blanco(self):
        if not self.datos_corregidos:
            messagebox.showinfo("Info", "No hay datos corregidos para mostrar.")
            return
        self.usando_correccion_blanco = not self.usando_correccion_blanco
        estado = "corregidos" if self.usando_correccion_blanco else "originales"
        messagebox.showinfo("Cambio de vista", f"Ahora mostrando datos {estado}.")
        self.graficar()

    def exportar_csv(self):
        if not self.archivos:
            messagebox.showinfo("Info", "No hay archivos cargados.")
            return

        nombre_base = simpledialog.askstring("Nombre base", "Nombre base para exportar") or "cv_export"

        # Exportar datos originales
        with open(f"{nombre_base}_original.csv", 'w', encoding='utf-8') as f:
            f.write("Potencial," + ",".join(self.archivos) + "\n")
            max_len = max(len(v[0]) for v in self.datos_originales.values())
            for i in range(max_len):
                fila = []
                for idx, nombre in enumerate(self.archivos):
                    pot, corr = self.datos_originales[nombre]
                    if i < len(pot):
                        if idx == 0:
                            fila.append(f"{pot[i]}")
                        fila.append(f"{corr[i]}")
                    else:
                        if idx == 0:
                            fila.append("")
                        fila.append("")
                f.write(",".join(fila) + "\n")

        # Exportar datos corregidos si existen
        if self.datos_corregidos:
            with open(f"{nombre_base}_corregidos.csv", 'w', encoding='utf-8') as f:
                f.write("Potencial," + ",".join(self.archivos) + "\n")
                max_len = max(len(v[0]) for v in self.datos_corregidos.values())
                for i in range(max_len):
                    fila = []
                    for idx, nombre in enumerate(self.archivos):
                        pot, corr = self.datos_corregidos.get(nombre, ([], []))
                        if i < len(pot):
                            if idx == 0:
                                fila.append(f"{pot[i]}")
                            fila.append(f"{corr[i]}")
                        else:
                            if idx == 0:
                                fila.append("")
                            fila.append("")
                    f.write(",".join(fila) + "\n")

        messagebox.showinfo("Exportado", "Datos exportados correctamente.")

    def exportar_jpg(self):
        ruta = filedialog.asksaveasfilename(defaultextension=".jpg", filetypes=[("JPG files", "*.jpg")])
        if ruta:
            self.fig.savefig(ruta, dpi=300, format='jpg')
            messagebox.showinfo("Exportado", f"GrÃ¡fica exportada como {ruta}")

# --- DRX ---
class ProcesadorDRX:
    def __init__(self, master):
        self.master = master
        self.master.title("ðŸ“Š DifracciÃ³n de Rayos X")
        self.master.geometry("1000x800")
        self.master.configure(bg="#f0e6fa")
        self.master.state('zoomed')

        self.datos_originales = {}
        self.datos_suavizados = {}
        self.mostrar = {}
        self.limites_originales = None
        self.longitud_onda = 1.5406  # Cu KÎ± (Ã…)
        self.etiqueta_x = tk.StringVar(value="2Î¸ (Â°)")
        self.etiqueta_y = tk.StringVar(value="Intensidad (u.a.)")

        self.xmin = tk.StringVar()
        self.xmax = tk.StringVar()
        self.ymin = tk.StringVar()
        self.ymax = tk.StringVar()
        self.var_ocultar_leyenda = tk.BooleanVar(value=False)

        # ----- ESTILOS -----
        color_fondo = "#dccff5"
        color_lista = "#cbb3f0"
        color_grafica = "#ba99eb"
        estilo_boton = {
            "bg": "#8644c5",
            "fg": "white",
            "font": ("Verdana", 10, "bold"),
            "bd": 0,
            "activebackground": "#5e2a9c",
            "activeforeground": "white"
        }
        fuente_label = ("Segoe UI", 9, "bold")

        # ----- FRAMES -----
        frame_controles = tk.Frame(master, bg=color_fondo)
        frame_controles.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        frame_lista = tk.Frame(master, bg=color_lista)
        frame_lista.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        frame_grafica = tk.Frame(master, bg=color_grafica)
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        # ----- BOTONES -----
        botones = [
            ("ðŸ“‚ Cargar archivos", self.cargar_archivos),
            ("ðŸ‘ï¸ Mostrar/Ocultar", self.toggle_mostrar_seleccion),
            ("ðŸ—‘ï¸ Eliminar", self.eliminar_archivos),
            ("ðŸ“Š Actualizar grÃ¡fica", self.actualizar_grafica),
            ("ðŸ’¾ Exportar CSV", self.exportar_csv),
            ("ðŸ–¼ï¸ Exportar JPG", self.exportar_jpg),
            ("ðŸ”„ Restablecer zoom", self.restablecer_zoom),
        ]
        for idx, (texto, comando) in enumerate(botones):
            tk.Button(frame_controles, text=texto, command=comando, **estilo_boton).grid(row=0, column=idx, padx=4)

        # ----- CHECK Y ENTRADAS DE RANGO -----
        tk.Checkbutton(frame_controles, text="Ocultar leyenda", variable=self.var_ocultar_leyenda,
                       command=self.actualizar_grafica, bg=color_fondo).grid(row=1, column=0, columnspan=2, sticky="w", padx=5)
        tk.Button(frame_controles, text="ðŸ”™ Regresar al menÃº", command=self.regresar_al_menu,
        bg="#b21e5a", fg="white", font=fuente_label).grid(row=1, column=7, sticky="e", padx=5)

# --- Etiquetas eje X e Y ---
        tk.Label(frame_controles, text="Etiqueta eje X:", bg=color_fondo, font=fuente_label).grid(row=2, column=0, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_x, width=20).grid(row=2, column=1, sticky='w', padx=5, pady=2)

        tk.Label(frame_controles, text="Etiqueta eje Y:", bg=color_fondo, font=fuente_label).grid(row=2, column=2, sticky='e', padx=5, pady=2)
        tk.Entry(frame_controles, textvariable=self.etiqueta_y, width=20).grid(row=2, column=3, sticky='w', padx=5, pady=2)

# --- LÃ­mites de ejes (Xmin/Xmax, Ymin/Ymax) ---
        limites = [
            ("X min:", self.xmin),
            ("X max:", self.xmax),
            ("Y min:", self.ymin),
            ("Y max:", self.ymax)
        ]
        for i, (texto, var) in enumerate(limites):
            col = (i % 2) * 2
            row = 3 + i // 2
            tk.Label(frame_controles, text=texto, bg=color_fondo, font=fuente_label).grid(row=row, column=col, sticky='e', padx=5, pady=2)
            tk.Entry(frame_controles, textvariable=var, width=20).grid(row=row, column=col + 1, sticky='w', padx=5, pady=2)


        # ----- LISTBOX -----
        tk.Label(frame_lista, text="Archivos cargados:", bg="#fff0e1", font=("Verdana", 10, "bold")).pack(anchor='w')
        self.listbox = tk.Listbox(frame_lista, selectmode=tk.EXTENDED, width=35, height=32)
        self.listbox.pack(fill=tk.BOTH, expand=True, pady=5)

        # ----- GRÃFICA -----
        self.fig = Figure(figsize=(8, 6))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_grafica)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        self.toolbar = NavigationToolbar2Tk(self.canvas, frame_grafica)
        self.toolbar.update()
        self.toolbar.pack(side=tk.BOTTOM, fill=tk.X)


    def leer_datos(self, ruta):
        longitudes = []
        intensidades = []
        with open(ruta, 'r', encoding='utf-8', errors='ignore') as f:
            for linea in f:
                linea = linea.strip()
                if not linea or linea.startswith('#'):
                    continue
                # Intentar separar por tab, espacio o coma
                if ',' in linea:
                    partes = linea.split(',')
                else:
                    partes = linea.split()
                if len(partes) >= 2:
                    try:
                        x = float(partes[0])
                        y = float(partes[1])
                        longitudes.append(x)
                        intensidades.append(y)
                    except:
                        continue
        if len(longitudes) < 5:
            raise ValueError("Datos insuficientes o formato incorrecto")
        return np.array(longitudes), np.array(intensidades)

    def cargar_archivos(self):
        rutas = filedialog.askopenfilenames(title="Selecciona archivos DRX",
                                            filetypes=[("Archivos DRX", "*.txt *.csv *.xy *.dat *.rd *.uxd")])
        if not rutas:
            return
        nuevos = 0
        for ruta in rutas:
            nombre = os.path.splitext(os.path.basename(ruta))[0]
            if nombre in self.datos_originales:
                messagebox.showwarning("Duplicado", f"Archivo '{nombre}' ya cargado.")
                continue
            try:
                x, y = self.leer_datos(ruta)
                if len(y) >= 11:
                    y_suave = savgol_filter(y, 11, 3)
                else:
                    y_suave = y
                self.datos_originales[nombre] = (x, y)
                self.datos_suavizados[nombre] = (x, y_suave)
                self.mostrar[nombre] = True
                self.listbox.insert(tk.END, nombre)
                nuevos += 1
            except Exception as e:
                messagebox.showerror("Error carga", f"No se pudo cargar '{nombre}': {e}")
        if nuevos > 0:
            self.actualizar_grafica()

    def toggle_mostrar_seleccion(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona archivo(s) para mostrar/ocultar.")
            return
        for i in seleccion:
            nombre = self.listbox.get(i)
            self.mostrar[nombre] = not self.mostrar.get(nombre, True)
        self.actualizar_grafica()

    def eliminar_archivos(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            messagebox.showinfo("Info", "Selecciona archivo(s) para eliminar.")
            return
        archivos = [self.listbox.get(i) for i in seleccion]
        if not messagebox.askyesno("Confirmar", f"Eliminar {len(archivos)} archivo(s)?"):
            return
        for n in archivos:
            self.datos_originales.pop(n, None)
            self.datos_suavizados.pop(n, None)
            self.mostrar.pop(n, None)
        for i in reversed(seleccion):
            self.listbox.delete(i)
        self.actualizar_grafica()

    def actualizar_grafica(self):
        self.ax.clear()
        any_data = False

        for nombre, (x, y) in self.datos_suavizados.items():
            if self.mostrar.get(nombre, True):
                self.ax.plot(x, y, label=nombre)
                any_data = True

    # Etiquetas personalizadas
        self.ax.set_xlabel(self.etiqueta_x.get(), fontsize=14)
        self.ax.set_ylabel(self.etiqueta_y.get(), fontsize=14)

    # EstÃ©tica del grÃ¡fico
        self.ax.grid(False)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))

        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)
        self.ax.minorticks_on()

    # Aplicar lÃ­mites si se proporcionan
        try:
            if self.xmin.get(): self.ax.set_xlim(left=float(self.xmin.get()))
            if self.xmax.get(): self.ax.set_xlim(right=float(self.xmax.get()))
            if self.ymin.get(): self.ax.set_ylim(bottom=float(self.ymin.get()))
            if self.ymax.get(): self.ax.set_ylim(top=float(self.ymax.get()))
        except ValueError:
            messagebox.showwarning("Advertencia", "Verifica que los lÃ­mites     ingresados sean valores numÃ©ricos.")

    # Leyenda
        if any_data and not self.var_ocultar_leyenda.get():
            self.ax.legend()

    # Guardar lÃ­mites originales para reset
        if any_data:
            self.limites_originales = (self.ax.get_xlim(), self.ax.get_ylim())

        self.canvas.draw()

    def exportar_csv(self):
        if not self.datos_suavizados:
            messagebox.showwarning("Advertencia", "No hay datos para exportar.")
            return

        ruta = filedialog.asksaveasfilename(defaultextension=".csv",
                                           filetypes=[("CSV files", "*.csv")])
        if not ruta:
            return

        with open(ruta, 'w', encoding='utf-8') as f:
            f.write("2theta, " + ", ".join(self.datos_suavizados.keys()) + "\n")

            ref_x = None
            for x, _ in self.datos_suavizados.values():
                ref_x = x
                break

            for i in range(len(ref_x)):
                fila = [f"{ref_x[i]:.4f}"]
                for nombre in self.datos_suavizados:
                    if self.mostrar.get(nombre, True):
                        y = self.datos_suavizados[nombre][1][i]
                        fila.append(f"{y:.6f}")
                f.write(",".join(fila) + "\n")
        messagebox.showinfo("ExportaciÃ³n", f"Datos exportados en:\n{ruta}")

    def exportar_jpg(self):
        ruta = filedialog.asksaveasfilename(defaultextension=".jpg",
                                           filetypes=[("JPG files", "*.jpg"), ("PNG files", "*.png")])
        if not ruta:
            return
        self.fig.savefig(ruta, dpi=300)
        messagebox.showinfo("ExportaciÃ³n", f"GrÃ¡fica guardada como:\n{ruta}")

    def restablecer_zoom(self):
        if self.limites_originales:
            self.ax.set_xlim(self.limites_originales[0])
            self.ax.set_ylim(self.limites_originales[1])
            self.canvas.draw()

    def regresar_al_menu(self):
        self.master.destroy()
        root_menu = tk.Tk()
        app = AppPrincipal(root_menu)
        root_menu.mainloop()

#--.Fluorescencia
class FluorescenciaApp:
    def __init__(self, master):
        self.master = master
        self.master.title("ðŸ”¬ Fluorescencia")
        self.master.geometry("920x780")
        self.master.configure(bg="#e6f0fa")
        self.master.state('zoomed')

        self.datos_originales = {}
        self.datos_suavizados = {}
        self.mostrar = {}
        self.limites_originales = None
        self.ver_suavizados = True
        self.var_ocultar_leyenda = tk.BooleanVar(value=False)
        self.etiqueta_x = tk.StringVar(value="Longitud de onda (nm)")
        self.etiqueta_y = tk.StringVar(value="Intensidad (a.u.)")
        self.xmin = tk.StringVar()
        self.xmax = tk.StringVar()
        self.ymin = tk.StringVar()
        self.ymax = tk.StringVar()

        estilo_boton = {
            "bg": "#f97f51",
            "fg": "white",
            "font": ("Verdana", 10, "bold"),
            "bd": 0,
            "activebackground": "#c44536",
            "activeforeground": "white"
        }

        fuente_label = ("Segoe UI", 9, "bold")
        color_fondo = "#fff0e1"


        frame_controles = tk.Frame(master, bg=color_fondo)
        frame_controles.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

        frame_lista = tk.Frame(master, bg="#fff0e1")
        frame_lista.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=5)

        frame_grafica = tk.Frame(master, bg="#b0d4fa")
        frame_grafica.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Controles
        botones = [
            ("ðŸ“‚ Cargar .SP", self.cargar_archivos),
            ("ðŸ‘ï¸ Mostrar/Ocultar", self.toggle_mostrar_seleccion),
            ("ðŸ—‘ï¸ Eliminar", self.eliminar_archivos),
            ("ðŸ“Š Actualizar", self.actualizar_grafica),
            ("ðŸ’¾ Exportar CSV", self.exportar_csv),
            ("ðŸ–¼ï¸ Guardar JPG", self.exportar_jpg),
            ("ðŸ” Restablecer Zoom", self.restablecer_zoom),
            ("â†”ï¸ Alternar suavizado/original", self.toggle_suavizado)
        ]
        for idx, (txt, cmd) in enumerate(botones):
            tk.Button(frame_controles, text=txt, command=cmd, **estilo_boton).grid(row=0, column=idx, padx=5)

        tk.Checkbutton(frame_controles, text="Ocultar leyenda", variable=self.var_ocultar_leyenda, bg=color_fondo, command=self.actualizar_grafica).grid(row=1, column=0, columnspan=2, sticky="w", padx=5)
        tk.Button(frame_controles, text="ðŸ”™ Regresar al menÃº", command=self.regresar_al_menu, bg="#b21e5a", fg="white", font=fuente_label).grid(row=1, column=7, sticky="e", padx=5)

        labels = [
            ("Etiqueta eje X:", self.etiqueta_x),
            ("Etiqueta eje Y:", self.etiqueta_y),
            ("X min:", self.xmin),
            ("X max:", self.xmax),
            ("Y min:", self.ymin),
            ("Y max:", self.ymax)
        ]
        for i, (texto, var) in enumerate(labels):
            row, col = 2 + i // 2, (i % 2) * 2
            tk.Label(frame_controles, text=texto, bg=color_fondo, font=fuente_label).grid(row=row, column=col, sticky='e', padx=5, pady=2)
            tk.Entry(frame_controles, textvariable=var, width=20).grid(row=row, column=col+1, sticky='w', padx=5, pady=2)

        tk.Label(frame_lista, text="Archivos cargados:", bg="#fff0e1", font=("Segoe UI", 10, "bold")).pack(anchor='w')
        self.listbox = tk.Listbox(frame_lista, selectmode=tk.EXTENDED, width=35, height=32)
        self.listbox.pack(fill=tk.BOTH, expand=True, pady=5)

        self.fig = Figure(figsize=(7.5, 5))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_grafica)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.toolbar = NavigationToolbar2Tk(self.canvas, frame_grafica)
        self.toolbar.update()
        self.toolbar.pack(side=tk.BOTTOM, fill=tk.X)

    def leer_SP(self, ruta):
        with open(ruta, 'r', encoding='utf-8', errors='ignore') as f:
            lineas = f.readlines()

        datos = []
        data_found = False
        for linea in lineas:
            linea = linea.strip()
            if "#DATA" in linea:
                data_found = True
                continue
            if data_found:
                if not linea or not any(c.isdigit() for c in linea):
                    continue
                partes = linea.replace(',', ' ').split()
                if len(partes) >= 2:
                    try:
                        x = float(partes[0])
                        y = float(partes[1])
                        datos.append((x, y))
                    except ValueError:
                        continue
        if len(datos) < 10:
            raise ValueError("Datos insuficientes")
        x, y = zip(*datos)
        return np.array(x), np.array(y)

    def cargar_archivos(self):
        rutas = filedialog.askopenfilenames(title="Selecciona archivos .SP de fluorescencia",
                                            filetypes=[("Archivos SP", "*.sp")])
        if not rutas:
            return
        nuevos = 0
        for ruta in rutas:
            nombre = os.path.splitext(os.path.basename(ruta))[0]
            if nombre in self.datos_originales:
                messagebox.showwarning("Duplicado", f"'{nombre}' ya fue cargado.")
                continue
            try:
                x, y = self.leer_SP(ruta)
                y_suave = savgol_filter(y, 21, 3) if len(y) >= 11 else y
                self.datos_originales[nombre] = (x, y)
                self.datos_suavizados[nombre] = (x, y_suave)
                self.mostrar[nombre] = True
                self.listbox.insert(tk.END, nombre)
                nuevos += 1
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo cargar '{nombre}': {e}")
        if nuevos > 0:
            self.actualizar_grafica()

    def actualizar_grafica(self):
        self.ax.clear()
        any_data = False
        fuente = self.datos_suavizados if self.ver_suavizados else self.datos_originales

        self.ax.set_xlabel(self.etiqueta_x.get(), fontsize=14)
        self.ax.set_ylabel(self.etiqueta_y.get(), fontsize=14)
        self.ax.grid(False)
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_position(('outward', 0))
        self.ax.spines['bottom'].set_position(('outward', 0))
        self.ax.tick_params(direction='in', length=6, width=1, which='major', top=False, right=False)
        self.ax.tick_params(direction='in', length=3, width=1, which='minor', top=False, right=False)
        self.ax.minorticks_on()
        self.ax.tick_params(axis='both', which='minor', length=3)

        for nombre in fuente:
            if self.mostrar.get(nombre, True):
                x, y = fuente[nombre]
                self.ax.plot(x, y, label=nombre)
                any_data = True

        self.ax.set_title("Datos suavizados" if self.ver_suavizados else "Datos originales", fontsize=14)

        if any_data and not self.var_ocultar_leyenda.get():
            self.ax.legend()

        try:
            xmin = float(self.xmin.get()) if self.xmin.get() else None
            xmax = float(self.xmax.get()) if self.xmax.get() else None
            ymin = float(self.ymin.get()) if self.ymin.get() else None
            ymax = float(self.ymax.get()) if self.ymax.get() else None

            if xmin is not None and xmax is not None:
                self.ax.set_xlim(xmin, xmax)
            if ymin is not None and ymax is not None:
                self.ax.set_ylim(ymin, ymax)
        except ValueError:
            messagebox.showwarning("LÃ­mites invÃ¡lidos", "Los valores de los ejes deben ser numÃ©ricos.")

        if any_data:
            self.limites_originales = (self.ax.get_xlim(), self.ax.get_ylim())

        self.canvas.draw()

    def toggle_mostrar_seleccion(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            return
        for i in seleccion:
            nombre = self.listbox.get(i)
            self.mostrar[nombre] = not self.mostrar.get(nombre, True)
        self.actualizar_grafica()

    def eliminar_archivos(self):
        seleccion = self.listbox.curselection()
        if not seleccion:
            return
        if not messagebox.askyesno("Confirmar", "Â¿Deseas eliminar los archivos seleccionados?"):
            return
        for i in reversed(seleccion):
            nombre = self.listbox.get(i)
            self.datos_originales.pop(nombre, None)
            self.datos_suavizados.pop(nombre, None)
            self.mostrar.pop(nombre, None)
            self.listbox.delete(i)
        self.actualizar_grafica()

    def exportar_csv(self):
        if not self.datos_suavizados:
            messagebox.showwarning("Advertencia", "No hay datos para exportar.")
            return

        base = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")])
        if not base:
            return

        base_sin_ext = os.path.splitext(base)[0]
        longitudes = list(self.datos_originales.values())[0][0]

        # Exportar datos originales
        with open(base_sin_ext + "_original.csv", 'w', encoding='utf-8') as f:
            encabezado = ["Longitud (nm)"] + [n for n in self.datos_originales if self.mostrar.get(n, True)]
            f.write(",".join(encabezado) + "\n")
            for i in range(len(longitudes)):
                fila = [f"{longitudes[i]:.3f}"]
                for nombre in self.datos_originales:
                    if self.mostrar.get(nombre, True):
                        fila.append(f"{self.datos_originales[nombre][1][i]:.6f}")
                f.write(",".join(fila) + "\n")

        # Exportar datos suavizados
        with open(base_sin_ext + "_suavizado.csv", 'w', encoding='utf-8') as f:
            encabezado = ["Longitud (nm)"] + [n for n in self.datos_suavizados if self.mostrar.get(n, True)]
            f.write(",".join(encabezado) + "\n")
            for i in range(len(longitudes)):
                fila = [f"{longitudes[i]:.3f}"]
                for nombre in self.datos_suavizados:
                    if self.mostrar.get(nombre, True):
                        fila.append(f"{self.datos_suavizados[nombre][1][i]:.6f}")
                f.write(",".join(fila) + "\n")

        messagebox.showinfo("Ã‰xito", f"Archivos exportados:\n{base_sin_ext}_original.csv\n{base_sin_ext}_suavizado.csv")

    def exportar_jpg(self):
        archivo = filedialog.asksaveasfilename(defaultextension=".jpg", filetypes=[("JPG", "*.jpg"), ("PNG", "*.png")])
        if not archivo:
            return
        self.fig.savefig(archivo, dpi=300)
        messagebox.showinfo("Guardado", f"GrÃ¡fica exportada como:\n{archivo}")

    def restablecer_zoom(self):
        if self.limites_originales:
            self.ax.set_xlim(self.limites_originales[0])
            self.ax.set_ylim(self.limites_originales[1])
            self.canvas.draw()

    def toggle_suavizado(self):
        self.ver_suavizados = not self.ver_suavizados
        self.actualizar_grafica()

    def regresar_al_menu(self):
        self.master.destroy()
        root_menu = tk.Tk()
        app = AppPrincipal(root_menu)
        root_menu.mainloop()

# --- Ventana principal con selecciÃ³n de mÃ³dulo ---
class AppPrincipal:
    def __init__(self, master):
        self.master = master
        self.master.title("ðŸ§ª AllSpec")
        self.master.geometry("400x500")
        self.master.configure(bg="#f0f4f8")
        self.master.state('zoomed')

        self.mensajes_dia = {
            0: "ðŸ” Lunes: Nueva semana,nuevos proyectos.",
            1: "ðŸ’¡ Martes: Recuerda siempre respaldar tus archivos.",
            2: "ðŸ§ª MiÃ©rcoles: No olvides calibrar tus equipos.",
            3: "ðŸ“Š Jueves: Utiliza siempre el equipo de seguridad.",
            4: "ðŸ§¼ Viernes: Limpia bien tus celdas.",
            5: "ðŸ“ SÃ¡bado: Revisa bien tus notas.",
            6: "ðŸ˜Œ Domingo: TÃ³mate un descanso, lo mereces."
        }

        self.label_hora = tk.Label(master,
                                   text="",
                                   font=("Times New Roman", 14),
                                   bg="#f0f4f8", fg="#444444")
        self.label_hora.place(relx=0.02, rely=0.055, anchor='nw')
        self.actualizar_hora()

        dia_actual = datetime.datetime.now().weekday()  # 0 = lunes, 6 = domingo
        mensaje_del_dia = self.mensajes_dia.get(dia_actual, "")

        self.label_mensaje_dia = tk.Label(master,
            text=mensaje_del_dia,
            font=("Times New Roman", 11, "italic"),
            bg="#f0f4f8", fg="#333333", wraplength=350,
            justify="left"
        )
        self.label_mensaje_dia.place(relx=0.02, rely=0.10, anchor='nw')

        tk.Label(master,
                 text="VersiÃ³n 2.1.0",
                 font=("Times New Roman", 12, "bold"),
                 bg="#f0f4f8", fg="#444444").place(relx=0.02, rely=0.015, anchor='nw')

        try:
            image_data = base64.b64decode(logo_base64)
            self.imagen = PhotoImage(data=image_data)
            tk.Label(master, image=self.imagen, bg="#f0f4f8").pack(pady=10)
        except Exception as e:
            print("No se pudo cargar la imagen embebida:", e)
        try:
            depto_img_data = base64.b64decode(logo_depto_base64)
            image = Image.open(io.BytesIO(depto_img_data))
            image = image.resize((250, 151), Image.Resampling.LANCZOS)
            self.logo_depto = ImageTk.PhotoImage(image)
            self.logo_label = tk.Label(master, image=self.logo_depto, bg="#f0f4f8")
            self.logo_label.place(relx=0.0, rely=1.0, anchor='sw', x=10, y=-30)
            self.logo_label.bind("<Button-1>", self.abrir_sitio)

            tk.Label(master,
               text="Para conocer nuestro departamento haga clic sobre el logo.",
               font=("Times New Roman", 11, "bold"),
               bg="#f0f4f8", fg="#444444", justify="left"
            ).place(relx=0.0, rely=1, anchor='sw', x=10, y=-10 )
        except Exception as e:
            print("No se pudo cargar el logo del departamento:", e)

        # Texto de bienvenida
        tk.Label(master,
                 text="Selecciona el tipo de anÃ¡lisis que desea realizar:",
                 font=("Times New Roman", 18),
                 bg="#f0f4f8", fg="#333333").pack(pady=10)

        # Estilo uniforme para los botones
        estilo_boton = {
            "width": 20,           # NÃºmero de caracteres aprox.
            "height": 2,           # NÃºmero de lÃ­neas
            "bg": "#b21e5a",
            "fg": "white",
            "font": ("Times New Roman", 15),
            "bd": 2,
            "relief": tk.RAISED,
            "activebackground": "#000000",
            "activeforeground": "white",
            "highlightbackground": "#b21e5a"
        }

# Frame contenedor centrado
        frame_botones = tk.Frame(master, bg="#f0f4f8")
        frame_botones.pack(pady=30)

# Fila 1
        btn_uvvis = tk.Button(frame_botones, text="ðŸ”¬ UV-Vis", command=self.abrir_uvvis, **estilo_boton)
        btn_fluor = tk.Button(frame_botones, text="ðŸ”§ Fluorescencia", command=self.abrir_fluorescencia, **estilo_boton)
        btn_uvvis.grid(row=0, column=0, padx=15, pady=10)
        btn_fluor.grid(row=0, column=1, padx=15, pady=10)

# Fila 2
        btn_ir = tk.Button(frame_botones, text="ðŸŒˆ Infrarrojo (IR)", command=self.abrir_ir, **estilo_boton)
        btn_voltam = tk.Button(frame_botones, text="âš¡ VoltamperometrÃ­a", command=self.abrir_voltam, **estilo_boton)
        btn_ir.grid(row=1, column=0, padx=15, pady=10)
        btn_voltam.grid(row=1, column=1, padx=15, pady=10)

# Fila 3 (centrado horizontalmente usando columnspan)
        btn_drx = tk.Button(frame_botones, text="ðŸ§± DifracciÃ³n RX", command=self.abrir_drx, **estilo_boton)
        btn_drx.grid(row=2, column=0, columnspan=2, pady=10)

# Asegura que ambas columnas se expandan igual
        frame_botones.grid_columnconfigure(0, weight=1)
        frame_botones.grid_columnconfigure(1, weight=1)


        mensaje = ("Este es un programa de acceso libre y gratuito, "
                   "cuya funciÃ³n es ayudar al procesamiento de datos.\nAtt: G.R.")

        departamento = "Departamento de QuÃ­mica\nUniversidad AutÃ³noma Metropolitana\nUnidad Iztapalapa"

        mensaje = ("Este es un programa de acceso libre y gratuito,\n"
                   "cuya funciÃ³n es ayudar al procesamiento de datos.\n"
                   "Att: Guillermo Reyna Rodriguez")

        departamento = ("Departamento de QuÃ­mica\n"
                        "Universidad AutÃ³noma Metropolitana\n"
                        "Unidad Iztapalapa")

        contacto= ("Contacto: lanyrrg@gmail.com")
        mensaje_sugerencia = "Dudas o sugerencias:"

        self.label_mensaje = tk.Label(master,
           text=mensaje,
           font=("Times New Roman", 14),
           bg="#f0f4f8", fg="#555555", justify="right",
           wraplength=400,
        )
        self.label_mensaje.place(relx=1.0, rely=1.0, anchor='se', x=-10, y=-90)

        self.label_departamento = tk.Label(master,
           text=departamento,
           font=("Times New Roman", 12, "bold"),
           bg="#f0f4f8", fg="#555555", justify="right",
           wraplength=400,
        )
        self.label_departamento.place(relx=1.0, rely=1.0, anchor='se', x=-10, y=-10)

        self.label_contacto = tk.Label(master,
           text=contacto,
           font=("Times New Roman", 12, "bold"),
           bg="#f0f4f8", fg="#555555", justify="right",
           wraplength=400,
        )
        self.label_contacto.place(relx=0.5, rely=1.0, anchor='s',y=-10)

        self.label_sugerencia = tk.Label(master,
           text=mensaje_sugerencia,
           font=("Times New Roman", 12),
           bg="#f0f4f8", fg="#555555", justify="right",
           wraplength=400,
        )
        self.label_sugerencia.place(relx=0.5, rely=1.0, anchor='s', y=-35)

 
        estilo_boton_pequeÃ±o = {
            "width": 12,
            "height": 1,
            "bg": "#b21e5a",
            "fg": "white",
            "font": ("Times New Roman", 12, "bold"),
            "bd": 2,
            "relief": tk.RAISED,
            "activebackground": "#000000",
            "activeforeground": "white",
            "highlightbackground": "#b21e5a"
        }

        btn_acerca = tk.Button(master, text="â„¹ï¸ Acerca de", command=self.mostrar_acerca, **estilo_boton_pequeÃ±o)
        btn_acerca.place(relx=1.0, rely=0.0, anchor="ne", x=-10, y=10)


    def abrir_sitio(self, event):
       webbrowser.open("http://quimica.izt.uam.mx/")

    def abrir_uvvis(self):
        self.master.destroy()
        root_uvvis = tk.Tk()
        app_uvvis = ProcesadorEspectros(root_uvvis)
        root_uvvis.mainloop()

    def abrir_ir(self):
        self.master.destroy()
        root_ir = tk.Tk()
        app_ir = ProcesadorIR(root_ir)
        root_ir.mainloop()

    def abrir_voltam(self):
        self.master.destroy()
        root_voltam = tk.Tk()
        app_voltam = CVApp(root_voltam)
        root_voltam.mainloop()

    def abrir_drx(self):
        self.master.destroy()
        root_drx = tk.Tk()
        app_drx = ProcesadorDRX(root_drx)
        root_drx.mainloop()

    def abrir_fluorescencia(self):
        self.master.destroy()
        root_fluorescencia = tk.Tk()
        app_fluorescencia = FluorescenciaApp(root_fluorescencia)
        root_fluorescencia.mainloop()

    def mostrar_acerca(self):
        mensaje = (
            "ðŸ§ª AllSpec â€“ VersiÃ³n 2.1.0\n\n"
            "Desarrollado por Guillermo Reyna RodrÃ­guez\n"
            "Departamento de QuÃ­mica\n"
            "Universidad AutÃ³noma Metropolitana â€“ Iztapalapa\n\n"
            "Este es un programa de acceso libre y gratuito,\n"
            "cuyo propÃ³sito es facilitar el procesamiento de datos\n"
            "espectroscÃ³picos y electroquÃ­micos.\n\n"
            "Contacto: lanyrrg@gmail.com"
        )
        messagebox.showinfo("Acerca de AllSpec", mensaje)

    def actualizar_hora(self):
        hora_actual = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        self.label_hora.config(text=f"ðŸ•’ {hora_actual}")
        self.master.after(1000, self.actualizar_hora)



if __name__ == '__main__':
    root = tk.Tk()
    app = AppPrincipal(root)
    root.mainloop()